#include <assimp/Exporter.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>

#include <cnoid/Body>
#include <cnoid/StdBodyLoader>
#include <cnoid/SceneDrawables>
#include <cnoid/MeshExtractor>
#include <cnoid/EigenUtil>

#include <iostream>
#include <sstream>
#include "../src/irsl_debug.h"

#include <set>

//// normal
// choreonoid vertex_array, normal_array, normal_index, index_array(triangle x 3)
//   index = index_array[n] ( 0 <= n < triangle * 3 )
//   vertex = vertex_array[index]
//   normal = normal_array[normal_index[index]]
// assimp vertex_array, normal_array, index_array(triangle * 3)
//   index = index_array[n] ( 0 <= n < triangle * 3 )
//   vertex = vertex_array[index]
//   normal = normal_array[index]

using namespace cnoid;

//// inline functions for printing
inline void _indent(int level, std::ostream &ostrm)
{
    for(int i = 0; i < level; i++) ostrm << " ";
}
inline void _print_vector(Vector3 &_vec, std::ostream &ostrm)
{
    // >precision
    ostrm << "\"";
    ostrm << _vec.x() << " ";
    ostrm << _vec.y() << " ";
    ostrm << _vec.z() << "\"";
    // <precision
}
inline void _print_float(double _in, std::ostream &ostrm)
{
    // >precision
    ostrm << "\"" << _in << "\"";
    // <precision
}
void _print_geom(std::string &fname, bool vis, std::ostream &ostrm)
{
    _indent(4, ostrm);
    if(vis) {
        ostrm << "<visual>";
    } else {
        ostrm << "<collision>";
    }
    ostrm << "<geometry>";
    ostrm << "<mesh filename=\"file://" << fname;
    ostrm << "\"/></geometry>";
    if(vis) {
        ostrm << "</visual>";
    } else {
        ostrm << "</collision>";
    }
    ostrm << std::endl;
}
void _print_mass_param(cnoid::Link *_lk, std::ostream &ostrm)
{
    Vector3 com_ = _lk->centerOfMass();
    Matrix3 Iner_ = _lk->I();
    _indent(4, ostrm);
    ostrm << "<inertial>" << std::endl;

    _indent(6, ostrm);
    ostrm << "<mass value=";
    _print_float(_lk->mass(), ostrm);
    ostrm << "/>" << std::endl;

    _indent(6, ostrm);
    ostrm << "<origin xyz=";
    _print_vector(com_, ostrm);
    ostrm << "/>" << std::endl;

    _indent(6, ostrm);
    ostrm << "<inertia ixx="; _print_float(Iner_(0,0), ostrm);
    ostrm << " ixy="; _print_float(Iner_(0,1), ostrm);
    ostrm << " ixz="; _print_float(Iner_(0,2), ostrm);
    ostrm << " iyy="; _print_float(Iner_(1,1), ostrm);
    ostrm << " iyz="; _print_float(Iner_(1,2), ostrm);
    ostrm << " izz="; _print_float(Iner_(2,2), ostrm);
    ostrm << "/>" << std::endl;

    _indent(4, ostrm);
    ostrm << "</inertial>" << std::endl;
}
void _print_urdf_header(std::string &_rname, std::ostream &ostrm)
{
    ostrm << "<?xml version=\"1.0\" ?>" << std::endl;
    ostrm << "<!-- This file was generated by robot assembler -->" << std::endl;
    ostrm << "<robot name=\"" << _rname << "\"" << std::endl;
    ostrm << "       xmlns:xi=\"http://www.w3.org/2001/XInclude\"" << std::endl;
    ostrm << "       xmlns:gazebo=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#gz\"" << std::endl;
    ostrm << "       xmlns:model=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#model\"" << std::endl;
    ostrm << "       xmlns:sensor=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor\"" << std::endl;
    ostrm << "       xmlns:body=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#body\"" << std::endl;
    ostrm << "       xmlns:geom=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#geom\"" << std::endl;
    ostrm << "       xmlns:joint=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#joint\"" << std::endl;
    ostrm << "       xmlns:interface=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#interface\"" << std::endl;
    ostrm << "       xmlns:rendering=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering\"" << std::endl;
    ostrm << "       xmlns:renderable=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable\"" << std::endl;
    ostrm << "       xmlns:controller=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#controller\"" << std::endl;
    ostrm << "       xmlns:physics=\"http://playerstage.sourceforge.net/gazebo/xmlschema/#physics\"" << std::endl;
    ostrm << "       xmlns:xacro=\"http://www.ros.org/wiki/xacro\">" << std::endl;
    ostrm << "  <xacro:macro name=\"gazebo_link_reference\" params=\"link_name mu1:=0.9 mu2:=0.9\" >" << std::endl;
    ostrm << "    <gazebo reference=\"${link_name}\">" << std::endl;
    ostrm << "      <mu1>${mu1}</mu1>" << std::endl;
    ostrm << "      <mu2>${mu2}</mu2>" << std::endl;
    ostrm << "    </gazebo>" << std::endl;
    ostrm << "  </xacro:macro>" << std::endl;
    ostrm << "  <xacro:macro name=\"gazebo_transmission\" params=\"joint_name\" >" << std::endl;
    ostrm << "    <transmission name=\"${joint_name}_trans\">" << std::endl;
    ostrm << "      <type>transmission_interface/SimpleTransmission</type>" << std::endl;
    ostrm << "      <joint name=\"${joint_name}\">" << std::endl;
    ostrm << "        <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>" << std::endl;
    ostrm << "        <!--hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface-->" << std::endl;
    ostrm << "      </joint>" << std::endl;
    ostrm << "      <actuator name=\"${joint_name}_motor\">" << std::endl;
    ostrm << "        <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>" << std::endl;
    ostrm << "        <!--hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface-->" << std::endl;
    ostrm << "        <mechanicalReduction>1</mechanicalReduction>" << std::endl;
    ostrm << "      </actuator>" << std::endl;
    ostrm << "    </transmission>" << std::endl;
    ostrm << "  </xacro:macro>" << std::endl;
    ostrm << "  <xacro:macro name=\"no_gazebo_transmission\" params=\"joint_name\" >" << std::endl;
    ostrm << "    <!-- dummy for fixed joint -->" << std::endl;
    ostrm << "  </xacro:macro>" << std::endl;
}
void _print_urdf_header_no_xacro(std::string &_rname, std::ostream &ostrm)
{
    ostrm << "<?xml version=\"1.0\" ?>" << std::endl;
    ostrm << "<!-- This file was generated by robot assembler -->" << std::endl;
    ostrm << "<robot name=\"" << _rname << "\">" << std::endl;
}
void _print_transmission(std::string &_joint_name, std::ostream &ostrm)
{
    _indent(2, ostrm);
    ostrm << "<xacro:gazebo_transmission joint_name=\"" << _joint_name << "\"/>" << std::endl;
}
void _print_transmission_no_xacro(std::string &_joint_name, std::ostream &ostrm)
{
    ostrm << "  <transmission name=\"" << _joint_name << "_trans\">" << std::endl;
    ostrm << "    <type>transmission_interface/SimpleTransmission</type>" << std::endl;
    ostrm << "    <joint name=\"" << _joint_name << "\">" << std::endl;
    ostrm << "      <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>" << std::endl;
    ostrm << "      <!--hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface-->" << std::endl;
    ostrm << "    </joint>" << std::endl;
    ostrm << "    <actuator name=\"" << _joint_name << "_motor\">" << std::endl;
    ostrm << "      <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>" << std::endl;
    ostrm << "      <!--hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface-->" << std::endl;
    ostrm << "      <mechanicalReduction>1</mechanicalReduction>" << std::endl;
    ostrm << "    </actuator>" << std::endl;
    ostrm << "  </transmission>" << std::endl;
}
void _print_urdf_footer(std::ostream &ostrm)
{
    ostrm << "</robot>" << std::endl;
}

//// store as mesh file using Assimp
class GeometryToAssimpImpl
{
public:
    GeometryToAssimpImpl () {}
    ~GeometryToAssimpImpl () {}

    MeshExtractor meshExtractor;
    void addMesh();
    void addPrimitive();
    aiScene *createScene();
    void storeScene(aiScene *_pscene, std::string &_filename, std::string &_id);

    void extractMeshSgNode(SgNode *_geometry)
    {
        vec_mesh.resize(0);
        vec_material.resize(0);
        meshExtractor.extract(_geometry,  [this](){ addMesh(); });
    }
    void extractPrimitiveSgNode(SgNode *_geometry)
    {
        vec_primitives.resize(0);
        meshExtractor.extract(_geometry,  [this](){ addPrimitive(); });
    }
    bool storeMeshGeometry(SgNode *_geometry, std::string &_filename, std::string _id = "")
    {
        extractMeshSgNode(_geometry);
        aiScene *res_ = createScene();
        if(!res_) {
            return false;
        }
        storeScene(res_, _filename, _id);
        delete res_;
        return true;
    }

    std::vector<aiMesh*> vec_mesh;
    std::vector<aiMaterial*> vec_material;
    std::vector<std::string> vec_primitives;

    bool primitive_to_mesh;
};
void GeometryToAssimpImpl::addPrimitive()
{
    SgMesh* mesh = meshExtractor.currentMesh();
    if(mesh->primitiveType() != SgMesh::BOX &&
       mesh->primitiveType() != SgMesh::CYLINDER &&
       mesh->primitiveType() != SgMesh::SPHERE ) {
        return;
    }
    DEBUG_STREAM(" primitive");
    SgShape* shape = meshExtractor.currentShape();
    const Affine3& T = meshExtractor.currentTransform();
    const Isometry3 &Ti = meshExtractor.currentTransformWithoutScaling();
    std::ostringstream strm;
    //origin
    {
        Vector3 trs_ = Ti.translation();
        Matrix3 mat_ = Ti.linear();
        Vector3 rpy_ = cnoid::rpyFromRot(mat_);
        strm << "<origin xyz="; _print_vector(trs_, strm);
        strm << " rpy="; _print_vector(rpy_, strm);
        strm << "/>";
    }
    switch(mesh->primitiveType()) {
    case SgMesh::BOX:
    {
        SgMesh::Box bx = mesh->primitive<SgMesh::Box>();
        //bx.size
        strm << "<geometry><box size=";
        _print_vector(bx.size, strm);
        strm << "/></geometry>" << std::endl;
        // material
    }
    break;
    case SgMesh::CYLINDER:
    {
        SgMesh::Cylinder cyl = mesh->primitive<SgMesh::Cylinder>();
        //cyl.radius;
        //cyl.height
        //strm << "<origin />";
        strm << "<geometry><cylinder radius=";
        _print_float(cyl.radius, strm);
        strm << " height=";
        _print_float(cyl.height, strm);
        strm << "/></geometry>" << std::endl;
        // material
    }
    break;
    case SgMesh::SPHERE:
    {
        SgMesh::Sphere sph = mesh->primitive<SgMesh::Sphere>();
        //sph.radius
        //strm << "<origin />";
        strm << "<geometry><shpere radius=";
        _print_float(sph.radius, strm);
        strm << "/></geometry>" << std::endl;
        // material
    }
    break;
    }

    if(strm.str().size() > 0) {
        vec_primitives.push_back(strm.str());
    }
}
void GeometryToAssimpImpl::addMesh()
{
    DEBUG_STREAM("");
    SgMesh* mesh = meshExtractor.currentMesh();
    SgShape* shape = meshExtractor.currentShape();
    const Affine3& T = meshExtractor.currentTransform();

    if(mesh->primitiveType() == SgMesh::MESH && mesh->hasTriangles()) {
        aiMesh *pMesh = new aiMesh();
        pMesh->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;
        const SgVertexArray& vertices_ = *mesh->vertices();
        const size_t numVertices = vertices_.size();
        pMesh->mNumVertices = numVertices;
        pMesh->mVertices = new aiVector3D [numVertices];

        DEBUG_STREAM(" numVertices : " << numVertices);
        //bool hasVertices() const { return (vertices_ && !vertices_->empty()); }
        for(size_t i = 0; i < numVertices; i++) {
            const Vector3 v = T * vertices_[i].cast<Isometry3::Scalar>();
            pMesh->mVertices[i].x = v.x();
            pMesh->mVertices[i].y = v.y();
            pMesh->mVertices[i].z = v.z();
        }

        if (mesh->hasNormals()) {
            const SgNormalArray& normals_ = *mesh->normals();
            const size_t numNormals = normals_.size();
            DEBUG_STREAM(" numNormals : " << numNormals);
            if(mesh->hasNormalIndices()) {
                const SgIndexArray& nIndices = mesh->normalIndices();
                DEBUG_STREAM(" nIndices.size() : " << nIndices.size());
                const SgIndexArray& vIndices = mesh->triangleVertices();
                DEBUG_STREAM(" vIndices.size() : " << vIndices.size());
                if (nIndices.size() == vIndices.size()) {
                    pMesh->mNormals  = new aiVector3D [pMesh->mNumVertices];
                    for (size_t k = 0; k < nIndices.size(); k++) {
                        Vector3 n = T * normals_[nIndices[k]].cast<Isometry3::Scalar>();
                        size_t idx = vIndices[k];
                        n.normalize();
                        pMesh->mNormals[idx].x = n.x();
                        pMesh->mNormals[idx].y = n.y();
                        pMesh->mNormals[idx].z = n.z();
                    }
                } else {
                    //// error
                }
            } else {
                if(numNormals == pMesh->mNumVertices) {
                    pMesh->mNormals  = new aiVector3D [numNormals];
                    for (size_t k = 0; k < numNormals; k++) {
                        Vector3 n = T * normals_[k].cast<Isometry3::Scalar>();
                        n.normalize();
                        pMesh->mNormals[k].x = n.x();
                        pMesh->mNormals[k].y = n.y();
                        pMesh->mNormals[k].z = n.z();
                    }
                } else {
                    //// error
                }
            }
        }

        if (mesh->hasColors()) {
            ERROR_STREAM(" !!!!!!!!!!!! hasColors !!!!!!!!!!!!");
            const SgColorArray& colors_ = *mesh->colors();
            const size_t numColors = colors_.size();
            DEBUG_STREAM(" numColors : " << numColors);
            if(mesh->hasColorIndices()) {
                const SgIndexArray& cIndices = mesh->colorIndices();
                DEBUG_STREAM(" cIndices.size() : " << cIndices.size());
                const SgIndexArray& vIndices = mesh->triangleVertices();
                DEBUG_STREAM(" vIndices.size() : " << vIndices.size());
                if (cIndices.size() == vIndices.size()) {
                    pMesh->mColors[0]  = new aiColor4D [pMesh->mNumVertices];
                    for (size_t k = 0; k < cIndices.size(); k++) {
                        Vector3f col_ = colors_[cIndices[k]];
                        size_t idx = vIndices[k];
                        aiColor4D &acol_ = pMesh->mColors[0][idx];
                        acol_.r = col_[0];
                        acol_.g = col_[1];
                        acol_.b = col_[2];
                        acol_.a = 1.0;
                    }
                } else {
                    //// error
                }
            } else {
                if(numColors == pMesh->mNumVertices) {
                    pMesh->mColors[0]  = new aiColor4D [numColors];
                    for (size_t k = 0; k < numColors; k++) {
                        Vector3f col_ = colors_[k];
                        aiColor4D &acol_ = pMesh->mColors[0][k];
                        acol_.r = col_[0];
                        acol_.g = col_[1];
                        acol_.b = col_[2];
                        acol_.a = 1.0;
                    }
                } else {
                    //// error
                }
           }
        }

        const int numTriangles = mesh->numTriangles();
        DEBUG_STREAM(" numTriangles : " << numTriangles);
        DEBUG_STREAM(" faceVertexIndices : " << mesh->faceVertexIndices().size());
        pMesh->mNumFaces = numTriangles;
        pMesh->mFaces = new aiFace[numTriangles];
        for(size_t i = 0; i < numTriangles; i++) {
            SgMesh::TriangleRef tri = mesh->triangle(i);
            pMesh->mFaces[i].mNumIndices = 3;
            pMesh->mFaces[i].mIndices = new unsigned int [3];

            pMesh->mFaces[i].mIndices[0] = tri[0];
            pMesh->mFaces[i].mIndices[1] = tri[1];
            pMesh->mFaces[i].mIndices[2] = tri[2];
        }
        vec_mesh.push_back(pMesh);

        { // Material
            SgMaterial *material_ = shape->material();
            aiMaterial* pcMat = new aiMaterial();
            aiString s; s.Set (AI_DEFAULT_MATERIAL_NAME);
            pcMat->AddProperty (&s, AI_MATKEY_NAME);
            const Vector3f &col_dif = material_->diffuseColor();
            aiColor4D colorDiffuse(col_dif[0], col_dif[1], col_dif[2], 1.0f);
            pcMat->AddProperty (&colorDiffuse, 1, AI_MATKEY_COLOR_DIFFUSE);
            const Vector3f &col_spe = material_->specularColor();
            aiColor4D colorSpecular(col_spe[0], col_spe[1], col_spe[2], 1.0f);
            pcMat->AddProperty (&colorSpecular, 1, AI_MATKEY_COLOR_SPECULAR);
            const Vector3f &col_emi = material_->emissiveColor();
            aiColor4D colorEmissive(col_emi[0], col_emi[1], col_emi[2], 1.0f);
            pcMat->AddProperty (&colorEmissive, 1, AI_MATKEY_COLOR_EMISSIVE);
            float ambi = material_->ambientIntensity();
            aiColor4D colorAmbient(ambi*col_dif[0], ambi*col_dif[1], ambi*col_dif[2], 1.0f);
            pcMat->AddProperty (&colorAmbient, 1, AI_MATKEY_COLOR_AMBIENT);
            float transp = material_->transparency();
            pcMat->AddProperty (&transp, 1, AI_MATKEY_COLOR_TRANSPARENT);

            vec_material.push_back(pcMat);
            pMesh->mMaterialIndex = vec_material.size() - 1;
        }
    } else {
        //// mesh generate
        DEBUG_STREAM(" primitive(not in gazebo)");
        switch(mesh->primitiveType()) {
        case SgMesh::CONE:
            break;
        case SgMesh::CAPSULE:
            break;
        }
        // material
    }
}
aiScene *GeometryToAssimpImpl::createScene()
{
    int num_mesh = vec_mesh.size();
    DEBUG_STREAM(" num_mesh: " << num_mesh);
    if (num_mesh == 0) {
        return nullptr;
    }
    aiScene *pScene = new aiScene();

    // store meshes
    pScene->mNumMeshes = num_mesh;
    pScene->mMeshes = new aiMesh*[num_mesh];
    for(int i = 0; i < num_mesh; i++) {
        pScene->mMeshes[i] = vec_mesh[i];
    }
    // create root node
    pScene->mRootNode = new aiNode();
    pScene->mRootNode->mNumMeshes = num_mesh;
    pScene->mRootNode->mMeshes = new unsigned int[num_mesh];
    for(int i = 0; i < num_mesh; i++) {
        pScene->mRootNode->mMeshes[i] = i;
    }
    pScene->mRootNode->mName.Set("root");

    // material
    int num_mat = vec_material.size();
    if (num_mat == 0) {
        pScene->mNumMaterials = 1;
        pScene->mMaterials = new aiMaterial*[1];
        // make default material
        aiMaterial* pcMat = new aiMaterial();
        aiString s; s.Set (AI_DEFAULT_MATERIAL_NAME);
        pcMat->AddProperty (&s, AI_MATKEY_NAME);
        aiColor4D colorDiffuse(0.8f, 0.8f, 0.8f, 1.0f);
        pcMat->AddProperty (&colorDiffuse, 1, AI_MATKEY_COLOR_DIFFUSE);
        pcMat->AddProperty (&colorDiffuse, 1, AI_MATKEY_COLOR_SPECULAR);
        aiColor4D colorAmbient(0.2f, 0.2f, 0.2f, 1.0f);
        pcMat->AddProperty (&colorAmbient, 1, AI_MATKEY_COLOR_AMBIENT);

        pScene->mMaterials[0] = pcMat;
    } else {
        pScene->mNumMaterials = num_mat;
        pScene->mMaterials = new aiMaterial*[num_mat];
        for(int i = 0; i < num_mat; i++) {
            pScene->mMaterials[i] = vec_material[i];
        }
    }

    return pScene;
}
#define SIZE_T_MAX (std::numeric_limits<size_t>::max())
void GeometryToAssimpImpl::storeScene(aiScene *_pscene, std::string &_filename, std::string &_id)
{
    std::string outf = _filename;
    std::string outext;
    if(_id.size() > 0) {
        outext = _id;
    } else {
        const std::string::size_type s = outf.find_last_of('.');
        if (s != std::string::npos) {
            outext = outf.substr (s+1);
        } else {
            std::cerr << ";; Can not find extention: " << outf << std::endl;
        }
    }

    Assimp::Exporter exporter;
    size_t outf_idx = SIZE_T_MAX;
    for(size_t i = 0, end = exporter.GetExportFormatCount(); i < end; ++i) {
        const aiExportFormatDesc* const e = exporter.GetExportFormatDescription(i);
        DEBUG_STREAM(" e->id = " << e->id << ", e->fileExtension = " << e->fileExtension);
        if (outext == e->id) {
            outf_idx = i; break;
        } else if (outext == e->fileExtension) {
            outf_idx = i; break;
        }
    }
    if (outf_idx == SIZE_T_MAX) { // unknown extention
        outext = "stl";
        for(size_t i = 0, end = exporter.GetExportFormatCount(); i < end; ++i) {
            const aiExportFormatDesc* const e = exporter.GetExportFormatDescription(i);
            if (outext == e->fileExtension) {
                outf_idx = i; break;
            }
        }
    }
    if (outf_idx == SIZE_T_MAX) outf_idx = 0;

    const aiExportFormatDesc* const e = exporter.GetExportFormatDescription(outf_idx);
    aiReturn ret = exporter.Export (_pscene, e->id, outf);
}

// class URDFCreator
////
void _dump_urdf(cnoid::Body *_body, bool _no_offset, bool _no_geom, bool _no_xacro, std::ostream &ostrm)
{
    //std::string robot_name = _body->name();
    std::string robot_name = _body->modelName();
    if(_no_xacro) {
        _print_urdf_header_no_xacro(robot_name, ostrm);
    } else {
        _print_urdf_header(robot_name, ostrm);
    }

    for(int i = 0; i < _body->numLinks(); i++) {
        cnoid::Link *lk = _body->link(i);
        //lk->jointId();
        //// link
        if(!_no_geom) {
            _indent(2, ostrm);
            ostrm << "<link name=\"" << lk->name() << "\" >" << std::endl;
            // geometry to file
            GeometryToAssimpImpl me;
            //std::string vfname = "/tmp/"; vfname += lk->name(); vfname += "_vis.stl";
            std::string vfname = "/tmp/"; vfname += lk->name(); vfname += "_vis.dae";
            std::string cfname = "/tmp/"; cfname += lk->name(); cfname += "_col.stl";

            //if(me.storeMeshGeometry(lk->visualShape(), vfname, "stlb")) {
            if(me.storeMeshGeometry(lk->visualShape(), vfname, "collada")) {
                _print_geom(vfname, true, ostrm);
            }
            me.extractPrimitiveSgNode(lk->visualShape());
            for (int i = 0; i < me.vec_primitives.size(); i++) {
                _indent(4, ostrm);
                ostrm << "<visual>";
                ostrm << me.vec_primitives[i];
                ostrm << "</visual>" << std::endl;
            }

            if(me.storeMeshGeometry(lk->collisionShape(), cfname, "stlb")) {
                _print_geom(cfname, false, ostrm);
            }
            me.extractPrimitiveSgNode(lk->collisionShape());
            for (int i = 0; i < me.vec_primitives.size(); i++) {
                _indent(4, ostrm);
                ostrm << "<collision>";
                ostrm << me.vec_primitives[i];
                ostrm << "</collision>" << std::endl;
            }

            _print_mass_param(lk, ostrm);
            _indent(2, ostrm);
            ostrm << "</link>" << std::endl;
        } else {
            _indent(2, ostrm);
            ostrm << "<link name=\"" << lk->name() << "\" />" << std::endl;
        }

        if(lk->isRoot()) {
            continue;
        }
        //// joint
        _indent(2, ostrm);
        std::string _jtype = "fixed";
        switch(lk->jointType()) {
        case cnoid::Link::RevoluteJoint:
            _jtype = "revolute";
            if(lk->q_upper() > 1e16) {
                _jtype = "continuous";
            }
            break;
        case cnoid::Link::PrismaticJoint:
            _jtype = "prismatic";
            break;
        case cnoid::Link::FreeJoint:
            _jtype = "floating";
            break;
            // _jtype = "planer"
        }
        ostrm << "<joint name=\"" << lk->jointName() << "\" ";
        ostrm << "type=\"" << _jtype << "\">" << std::endl;

        cnoid::Link *plk = lk->parent();
        if(!!plk) {
            _indent(4, ostrm);
            ostrm << "<parent link=\"" << plk->name() << "\"/>" << std::endl;
        }
        _indent(4, ostrm);
        ostrm << "<child link=\"" << lk->name() << "\"/>" << std::endl;

        if (!_no_offset) {
            _indent(4, ostrm);
            Isometry3::TranslationPart ltrans(lk->translation());
            Isometry3::TranslationPart ptrans(plk->translation());
            Matrix3 lrot(lk->rotation());
            Matrix3 prot(plk->rotation());

            Matrix3 prot_inv = prot.transpose();
            Matrix3 trot = prot_inv * lrot;
            Vector3 _xyz = prot_inv * (ltrans - ptrans);
            Vector3 _rpy = cnoid::rpyFromRot(trot);

            ostrm << "<origin xyz=";
            _print_vector(_xyz, ostrm);
            ostrm << " rpy=";
            _print_vector(_rpy, ostrm);
            ostrm << "/>" << std::endl;
        }

        if(!lk->isFixedJoint()) {
            if(!_no_offset) {
                Vector3 ax_ = lk->a();
                _indent(4, ostrm);
                ostrm << "<axis xyz=";
                _print_vector(ax_, ostrm);
                ostrm << "/>" << std::endl;
            }
            _indent(4, ostrm);
            ostrm << "<limit lower=";
            _print_float(lk->q_lower(), ostrm);
            ostrm << " upper=";
            _print_float(lk->q_upper(), ostrm);
            ostrm << " velocity=";
            _print_float(lk->dq_upper(), ostrm);
            ostrm << " effort=";
            _print_float(lk->u_upper(), ostrm);
            ostrm << "/>" << std::endl;
        }
        _indent(2, ostrm);
        ostrm << "</joint>" << std::endl;

        //// print transmission
        if(!lk->isFixedJoint()) {
            std::string jname_(lk->jointName());
            if(_no_xacro) {
                _print_transmission_no_xacro(jname_, ostrm);
            } else {
                _print_transmission(jname_, ostrm);
            }
        }
    }
    _print_urdf_footer(ostrm);
}

int main(int argc, char **argv)
{
    StdBodyLoader ld;
    Body bd;
    std::string fname;
    bool no_offset = false;
    bool no_geom = false;
    bool no_xacro = false;
    if(argc > 1) {
        fname = std::string(argv[argc-1]);
        for(int i = 0; i < argc; i++) {
            if("--no-offset" == std::string(argv[i])) {
                no_offset = true;
            }
            if("--no-geometry" == std::string(argv[i])) {
                no_geom = true;
            }
            if("--no-xacro" == std::string(argv[i])) {
                no_xacro = true;
            }
        }
        std::cerr << "fname: " << fname << std::endl;
        std::cerr << "no-offset: " << no_offset << std::endl;
        std::cerr << "no-geometry: " << no_geom << std::endl;
        std::cerr << "no-xacro: " << no_xacro << std::endl;

        ld.load(&bd, fname);
        bd.updateLinkTree();
        bd.initializePosition();
        bd.calcForwardKinematics();

        _dump_urdf(&bd, no_offset, no_geom, no_xacro, std::cout);
    }

    return 0;
}
